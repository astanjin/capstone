{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { CodedError } from '@unimodules/core';\nimport { CryptoEncoding } from \"./Crypto.types\";\nexport default {\n  get name() {\n    return 'ExpoCrypto';\n  },\n  digestStringAsync: function digestStringAsync(algorithm, data, options) {\n    var encoder, buffer, hashedData;\n    return _regeneratorRuntime.async(function digestStringAsync$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (crypto.subtle) {\n              _context.next = 2;\n              break;\n            }\n            throw new CodedError('ERR_CRYPTO_UNAVAILABLE', 'Access to the WebCrypto API is restricted to secure origins (https).');\n          case 2:\n            encoder = new TextEncoder();\n            buffer = encoder.encode(data);\n            _context.next = 6;\n            return _regeneratorRuntime.awrap(crypto.subtle.digest(algorithm, buffer));\n          case 6:\n            hashedData = _context.sent;\n            if (!(options.encoding === CryptoEncoding.HEX)) {\n              _context.next = 11;\n              break;\n            }\n            return _context.abrupt(\"return\", hexString(hashedData));\n          case 11:\n            if (!(options.encoding === CryptoEncoding.BASE64)) {\n              _context.next = 13;\n              break;\n            }\n            return _context.abrupt(\"return\", btoa(String.fromCharCode.apply(String, _toConsumableArray(new Uint8Array(hashedData)))));\n          case 13:\n            throw new CodedError('ERR_CRYPTO_DIGEST', 'Invalid encoding type provided.');\n          case 14:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }\n};\nfunction hexString(buffer) {\n  var byteArray = new Uint8Array(buffer);\n  var hexCodes = _toConsumableArray(byteArray).map(function (value) {\n    var hexCode = value.toString(16);\n    var paddedHexCode = hexCode.padStart(2, '0');\n    return paddedHexCode;\n  });\n  return hexCodes.join('');\n}","map":{"version":3,"mappings":";;AAAA,SAASA,UAAU,QAAQ,kBAAkB;AAE7C,SAAgCC,cAAc;AAE9C,eAAe;EACb,IAAIC,IAAI;IACN,OAAO,YAAY;EACrB,CAAC;EACKC,iBAAiB,6BACrBC,SAAgC,EAChCC,IAAY,EACZC,OAA4B;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA,IAEvBC,MAAM,CAACC,MAAM;cAAA;cAAA;YAAA;YAAA,MACV,IAAIR,UAAU,CAClB,wBAAwB,EACxB,sEAAsE,CACvE;UAAA;YAEGS,OAAO,GAAG,IAAIC,WAAW,EAAE;YAC3BC,MAAM,GAAGF,OAAO,CAACG,MAAM,CAACP,IAAI,CAAC;YAAA;YAAA,iCACVE,MAAM,CAACC,MAAM,CAACK,MAAM,CAACT,SAAS,EAAEO,MAAM,CAAC;UAAA;YAA1DG,UAAU;YAAA,MACZR,OAAO,CAACS,QAAQ,KAAKd,cAAc,CAACe,GAAG;cAAA;cAAA;YAAA;YAAA,iCAClCC,SAAS,CAACH,UAAU,CAAC;UAAA;YAAA,MACnBR,OAAO,CAACS,QAAQ,KAAKd,cAAc,CAACiB,MAAM;cAAA;cAAA;YAAA;YAAA,iCAC5CC,IAAI,CAACC,MAAM,CAACC,YAAY,OAAnBD,MAAM,qBAAiB,IAAIE,UAAU,CAACR,UAAU,CAAC,EAAC,CAAC;UAAA;YAAA,MAE3D,IAAId,UAAU,CAAC,mBAAmB,EAAE,iCAAiC,CAAC;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA;CAE/E;AAED,SAASiB,SAAS,CAACN,MAAmB;EACpC,IAAMY,SAAS,GAAG,IAAID,UAAU,CAACX,MAAM,CAAC;EAExC,IAAMa,QAAQ,GAAG,mBAAID,SAAS,EAAEE,GAAG,CAAC,eAAK,EAAG;IAC1C,IAAMC,OAAO,GAAGC,KAAK,CAACC,QAAQ,CAAC,EAAE,CAAC;IAClC,IAAMC,aAAa,GAAGH,OAAO,CAACI,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC;IAC9C,OAAOD,aAAa;EACtB,CAAC,CAAC;EAEF,OAAOL,QAAQ,CAACO,IAAI,CAAC,EAAE,CAAC;AAC1B","names":["CodedError","CryptoEncoding","name","digestStringAsync","algorithm","data","options","crypto","subtle","encoder","TextEncoder","buffer","encode","digest","hashedData","encoding","HEX","hexString","BASE64","btoa","String","fromCharCode","Uint8Array","byteArray","hexCodes","map","hexCode","value","toString","paddedHexCode","padStart","join"],"sourceRoot":"","sources":["../src/ExpoCrypto.web.ts"],"sourcesContent":["import { CodedError } from '@unimodules/core';\n\nimport { CryptoDigestAlgorithm, CryptoEncoding, CryptoDigestOptions } from './Crypto.types';\n\nexport default {\n  get name(): string {\n    return 'ExpoCrypto';\n  },\n  async digestStringAsync(\n    algorithm: CryptoDigestAlgorithm,\n    data: string,\n    options: CryptoDigestOptions\n  ): Promise<string> {\n    if (!crypto.subtle) {\n      throw new CodedError(\n        'ERR_CRYPTO_UNAVAILABLE',\n        'Access to the WebCrypto API is restricted to secure origins (https).'\n      );\n    }\n    const encoder = new TextEncoder();\n    const buffer = encoder.encode(data);\n    const hashedData = await crypto.subtle.digest(algorithm, buffer);\n    if (options.encoding === CryptoEncoding.HEX) {\n      return hexString(hashedData);\n    } else if (options.encoding === CryptoEncoding.BASE64) {\n      return btoa(String.fromCharCode(...new Uint8Array(hashedData)));\n    }\n    throw new CodedError('ERR_CRYPTO_DIGEST', 'Invalid encoding type provided.');\n  },\n};\n\nfunction hexString(buffer: ArrayBuffer): string {\n  const byteArray = new Uint8Array(buffer);\n\n  const hexCodes = [...byteArray].map(value => {\n    const hexCode = value.toString(16);\n    const paddedHexCode = hexCode.padStart(2, '0');\n    return paddedHexCode;\n  });\n\n  return hexCodes.join('');\n}\n"]},"metadata":{},"sourceType":"module"}