{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { Platform } from '@unimodules/core';\nimport Constants, { ExecutionEnvironment } from 'expo-constants';\nimport * as Linking from 'expo-linking';\nimport { dismissAuthSession, openAuthSessionAsync } from 'expo-web-browser';\nimport { AuthRequest } from \"./AuthRequest\";\nimport { CodeChallengeMethod, Prompt, ResponseType } from \"./AuthRequest.types\";\nimport { fetchDiscoveryAsync, resolveDiscoveryAsync } from \"./Discovery\";\nimport { generateHexStringAsync } from \"./PKCE\";\nimport { getQueryParams } from \"./QueryParams\";\nimport { getSessionUrlProvider } from \"./SessionUrlProvider\";\nvar _authLock = false;\nvar sessionUrlProvider = getSessionUrlProvider();\nexport function startAsync(options) {\n  var returnUrl, authUrl, startUrl, showInRecents, result, _getQueryParams, params, errorCode;\n  return _regeneratorRuntime.async(function startAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          returnUrl = options.returnUrl || sessionUrlProvider.getDefaultReturnUrl();\n          authUrl = options.authUrl;\n          startUrl = sessionUrlProvider.getStartUrl(authUrl, returnUrl);\n          showInRecents = options.showInRecents || false;\n          if (authUrl) {\n            _context.next = 6;\n            break;\n          }\n          throw new Error('No authUrl provided to AuthSession.startAsync. An authUrl is required -- it points to the page where the user will be able to sign in.');\n        case 6:\n          if (!_authLock) {\n            _context.next = 9;\n            break;\n          }\n          if (__DEV__) {\n            console.warn('Attempted to call AuthSession.startAsync multiple times while already active. Only one AuthSession can be active at any given time.');\n          }\n          return _context.abrupt(\"return\", {\n            type: 'locked'\n          });\n        case 9:\n          _authLock = true;\n          _context.prev = 10;\n          _context.next = 13;\n          return _regeneratorRuntime.awrap(_openWebBrowserAsync(startUrl, returnUrl, showInRecents));\n        case 13:\n          result = _context.sent;\n        case 14:\n          _context.prev = 14;\n          _authLock = false;\n          return _context.finish(14);\n        case 17:\n          if (result) {\n            _context.next = 19;\n            break;\n          }\n          throw new Error('Unexpected missing AuthSession result');\n        case 19:\n          if (result.url) {\n            _context.next = 25;\n            break;\n          }\n          if (!result.type) {\n            _context.next = 24;\n            break;\n          }\n          return _context.abrupt(\"return\", result);\n        case 24:\n          throw new Error('Unexpected AuthSession result with missing type');\n        case 25:\n          _getQueryParams = getQueryParams(result.url), params = _getQueryParams.params, errorCode = _getQueryParams.errorCode;\n          return _context.abrupt(\"return\", {\n            type: errorCode ? 'error' : 'success',\n            params: params,\n            errorCode: errorCode,\n            authentication: null,\n            url: result.url\n          });\n        case 27:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[10,, 14, 17]], Promise);\n}\nexport function dismiss() {\n  dismissAuthSession();\n}\nexport function getDefaultReturnUrl() {\n  return sessionUrlProvider.getDefaultReturnUrl();\n}\nexport function getRedirectUrl(path) {\n  return sessionUrlProvider.getRedirectUrl(path);\n}\nexport function makeRedirectUri() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n    native = _ref.native,\n    path = _ref.path,\n    preferLocalhost = _ref.preferLocalhost,\n    useProxy = _ref.useProxy;\n  if (Platform.OS !== 'web') {\n    if (Constants.executionEnvironment === ExecutionEnvironment.Bare) {\n      if (!native) {\n        console.warn(\"makeRedirectUri requires you define a `native` scheme for bare workflow, and standalone native apps, you'll need to manually define it based on your app's URI schemes.\");\n      }\n      return native || '';\n    }\n    if (Constants.executionEnvironment === ExecutionEnvironment.Standalone && native) {\n      return native;\n    }\n  }\n  if (!useProxy || Platform.OS === 'web') {\n    var url = Linking.makeUrl(path);\n    if (preferLocalhost) {\n      var ipAddress = url.match(/\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b/);\n      if (ipAddress != null && ipAddress.length) {\n        var _url$split = url.split(ipAddress[0]),\n          _url$split2 = _slicedToArray(_url$split, 2),\n          protocol = _url$split2[0],\n          _path = _url$split2[1];\n        return protocol + \"localhost\" + _path;\n      }\n    }\n    return url;\n  }\n  return sessionUrlProvider.getRedirectUrl(path);\n}\nexport function loadAsync(config, issuerOrDiscovery) {\n  var request, discovery;\n  return _regeneratorRuntime.async(function loadAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          request = new AuthRequest(config);\n          _context2.next = 3;\n          return _regeneratorRuntime.awrap(resolveDiscoveryAsync(issuerOrDiscovery));\n        case 3:\n          discovery = _context2.sent;\n          _context2.next = 6;\n          return _regeneratorRuntime.awrap(request.makeAuthUrlAsync(discovery));\n        case 6:\n          return _context2.abrupt(\"return\", request);\n        case 7:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nfunction _openWebBrowserAsync(startUrl, returnUrl, showInRecents) {\n  var result;\n  return _regeneratorRuntime.async(function _openWebBrowserAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return _regeneratorRuntime.awrap(openAuthSessionAsync(startUrl, returnUrl, {\n            showInRecents: showInRecents\n          }));\n        case 2:\n          result = _context3.sent;\n          if (!(result.type === 'cancel' || result.type === 'dismiss')) {\n            _context3.next = 5;\n            break;\n          }\n          return _context3.abrupt(\"return\", {\n            type: result.type\n          });\n        case 5:\n          return _context3.abrupt(\"return\", result);\n        case 6:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport { useAutoDiscovery, useAuthRequest } from \"./AuthRequestHooks\";\nexport { AuthError, TokenError } from \"./Errors\";\nexport { AuthRequest, CodeChallengeMethod, Prompt, ResponseType, resolveDiscoveryAsync, fetchDiscoveryAsync, generateHexStringAsync };\nexport { TokenResponse, AccessTokenRequest, RefreshTokenRequest, RevokeTokenRequest, revokeAsync, refreshAsync, exchangeCodeAsync, fetchUserInfoAsync } from \"./TokenRequest\";\nexport * from \"./TokenRequest.types\";","map":{"version":3,"mappings":"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","names":["Platform","Constants","ExecutionEnvironment","Linking","dismissAuthSession","openAuthSessionAsync","AuthRequest","CodeChallengeMethod","Prompt","ResponseType","fetchDiscoveryAsync","resolveDiscoveryAsync","generateHexStringAsync","getQueryParams","getSessionUrlProvider","_authLock","sessionUrlProvider","startAsync","options","returnUrl","getDefaultReturnUrl","authUrl","startUrl","getStartUrl","showInRecents","Error","__DEV__","console","warn","type","_openWebBrowserAsync","result","url","params","errorCode","authentication","dismiss","getRedirectUrl","path","makeRedirectUri","native","preferLocalhost","useProxy","OS","executionEnvironment","Bare","Standalone","makeUrl","ipAddress","match","length","split","protocol","loadAsync","config","issuerOrDiscovery","request","discovery","makeAuthUrlAsync","useAutoDiscovery","useAuthRequest","AuthError","TokenError","TokenResponse","AccessTokenRequest","RefreshTokenRequest","RevokeTokenRequest","revokeAsync","refreshAsync","exchangeCodeAsync","fetchUserInfoAsync"],"sourceRoot":"","sources":["../src/AuthSession.ts"],"sourcesContent":["import { Platform } from '@unimodules/core';\nimport Constants, { ExecutionEnvironment } from 'expo-constants';\nimport * as Linking from 'expo-linking';\nimport { dismissAuthSession, openAuthSessionAsync } from 'expo-web-browser';\n\nimport { AuthRequest } from './AuthRequest';\nimport {\n  AuthRequestConfig,\n  AuthRequestPromptOptions,\n  CodeChallengeMethod,\n  Prompt,\n  ResponseType,\n} from './AuthRequest.types';\nimport {\n  AuthSessionOptions,\n  AuthSessionRedirectUriOptions,\n  AuthSessionResult,\n} from './AuthSession.types';\nimport {\n  DiscoveryDocument,\n  fetchDiscoveryAsync,\n  Issuer,\n  IssuerOrDiscovery,\n  ProviderMetadata,\n  resolveDiscoveryAsync,\n} from './Discovery';\nimport { generateHexStringAsync } from './PKCE';\nimport { getQueryParams } from './QueryParams';\nimport { getSessionUrlProvider } from './SessionUrlProvider';\n\nlet _authLock = false;\nconst sessionUrlProvider = getSessionUrlProvider();\n\nexport async function startAsync(options: AuthSessionOptions): Promise<AuthSessionResult> {\n  const returnUrl = options.returnUrl || sessionUrlProvider.getDefaultReturnUrl();\n  const authUrl = options.authUrl;\n  const startUrl = sessionUrlProvider.getStartUrl(authUrl, returnUrl);\n  const showInRecents = options.showInRecents || false;\n\n  // Prevent accidentally starting to an empty url\n  if (!authUrl) {\n    throw new Error(\n      'No authUrl provided to AuthSession.startAsync. An authUrl is required -- it points to the page where the user will be able to sign in.'\n    );\n  }\n\n  // Prevent multiple sessions from running at the same time, WebBrowser doesn't\n  // support it this makes the behavior predictable.\n  if (_authLock) {\n    if (__DEV__) {\n      console.warn(\n        'Attempted to call AuthSession.startAsync multiple times while already active. Only one AuthSession can be active at any given time.'\n      );\n    }\n\n    return { type: 'locked' };\n  }\n\n  // About to start session, set lock\n  _authLock = true;\n\n  let result;\n  try {\n    result = await _openWebBrowserAsync(startUrl, returnUrl, showInRecents);\n  } finally {\n    // WebBrowser session complete, unset lock\n    _authLock = false;\n  }\n\n  // Handle failures\n  if (!result) {\n    throw new Error('Unexpected missing AuthSession result');\n  }\n  if (!result.url) {\n    if (result.type) {\n      return result;\n    } else {\n      throw new Error('Unexpected AuthSession result with missing type');\n    }\n  }\n\n  const { params, errorCode } = getQueryParams(result.url);\n\n  return {\n    type: errorCode ? 'error' : 'success',\n    params,\n    errorCode,\n    authentication: null,\n    url: result.url,\n  };\n}\n\nexport function dismiss() {\n  dismissAuthSession();\n}\n\nexport function getDefaultReturnUrl(): string {\n  return sessionUrlProvider.getDefaultReturnUrl();\n}\n\n/**\n * @deprecated Use `makeRedirectUri({ path, useProxy })` instead.\n *\n * @param path\n */\nexport function getRedirectUrl(path?: string): string {\n  return sessionUrlProvider.getRedirectUrl(path);\n}\n\n/**\n * Create a redirect url for the current platform.\n * - **Web:** Generates a path based on the current \\`window.location\\`. For production web apps you should hard code the URL.\n * - **Managed, and Custom workflow:** Uses the `scheme` property of your `app.config.js` or `app.json`.\n *   - **Proxy:** Uses auth.expo.io as the base URL for the path. This only works in Expo client and standalone environments.\n * - **Bare workflow:** Will fallback to using the `native` option for bare workflow React Native apps.\n *\n * @param options Additional options for configuring the path.\n */\nexport function makeRedirectUri({\n  native,\n  path,\n  preferLocalhost,\n  useProxy,\n}: AuthSessionRedirectUriOptions = {}): string {\n  if (Platform.OS !== 'web') {\n    // Bare workflow\n    if (Constants.executionEnvironment === ExecutionEnvironment.Bare) {\n      if (!native) {\n        // TODO(Bacon): Link to docs or fyi\n        console.warn(\n          \"makeRedirectUri requires you define a `native` scheme for bare workflow, and standalone native apps, you'll need to manually define it based on your app's URI schemes.\"\n        );\n      }\n      // Returning an empty string makes types easier to work with.\n      // Server will throw an error about the invalid URI scheme.\n      return native || '';\n    }\n    // Should use the user-defined native scheme in standalone builds\n    if (Constants.executionEnvironment === ExecutionEnvironment.Standalone && native) {\n      return native;\n    }\n  }\n  if (!useProxy || Platform.OS === 'web') {\n    const url = Linking.makeUrl(path);\n\n    if (preferLocalhost) {\n      const ipAddress = url.match(\n        /\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b/\n      );\n      // Only replace if an IP address exists\n      if (ipAddress?.length) {\n        const [protocol, path] = url.split(ipAddress[0]);\n        return `${protocol}localhost${path}`;\n      }\n    }\n\n    return url;\n  }\n  // Attempt to use the proxy\n  return sessionUrlProvider.getRedirectUrl(path);\n}\n\n/**\n * Build an `AuthRequest` and load it before returning.\n *\n * @param config\n * @param issuerOrDiscovery\n */\nexport async function loadAsync(\n  config: AuthRequestConfig,\n  issuerOrDiscovery: IssuerOrDiscovery\n): Promise<AuthRequest> {\n  const request = new AuthRequest(config);\n  const discovery = await resolveDiscoveryAsync(issuerOrDiscovery);\n  await request.makeAuthUrlAsync(discovery);\n  return request;\n}\n\nasync function _openWebBrowserAsync(startUrl: string, returnUrl: string, showInRecents: boolean) {\n  // $FlowIssue: Flow thinks the awaited result can be a promise\n  const result = await openAuthSessionAsync(startUrl, returnUrl, { showInRecents });\n  if (result.type === 'cancel' || result.type === 'dismiss') {\n    return { type: result.type };\n  }\n\n  return result;\n}\n\nexport { useAutoDiscovery, useAuthRequest } from './AuthRequestHooks';\nexport { AuthError, TokenError } from './Errors';\n\nexport {\n  AuthSessionOptions,\n  AuthSessionRedirectUriOptions,\n  AuthSessionResult,\n  AuthRequest,\n  AuthRequestConfig,\n  AuthRequestPromptOptions,\n  CodeChallengeMethod,\n  DiscoveryDocument,\n  Issuer,\n  IssuerOrDiscovery,\n  Prompt,\n  ProviderMetadata,\n  ResponseType,\n  resolveDiscoveryAsync,\n  fetchDiscoveryAsync,\n  generateHexStringAsync,\n};\n\nexport {\n  // Token classes\n  TokenResponse,\n  AccessTokenRequest,\n  RefreshTokenRequest,\n  RevokeTokenRequest,\n  // Token methods\n  revokeAsync,\n  refreshAsync,\n  exchangeCodeAsync,\n  fetchUserInfoAsync,\n} from './TokenRequest';\n\n// Token types\nexport * from './TokenRequest.types';\n"]},"metadata":{},"sourceType":"module"}