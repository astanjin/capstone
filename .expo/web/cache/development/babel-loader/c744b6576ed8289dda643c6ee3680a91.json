{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { UnavailabilityError } from '@unimodules/core';\nimport { toByteArray } from 'base64-js';\nimport ExpoRandom from \"./ExpoRandom\";\nfunction assertByteCount(value, methodName) {\n  if (typeof value !== 'number' || isNaN(value) || Math.floor(value) < 0 || Math.floor(value) > 1024) {\n    throw new TypeError(\"expo-random: \" + methodName + \"(\" + value + \") expected a valid number from range 0...1024\");\n  }\n}\nexport function getRandomBytes(byteCount) {\n  assertByteCount(byteCount, 'getRandomBytes');\n  var validByteCount = Math.floor(byteCount);\n  if (ExpoRandom.getRandomBytes) {\n    return ExpoRandom.getRandomBytes(validByteCount);\n  } else if (ExpoRandom.getRandomBase64String) {\n    var base64 = ExpoRandom.getRandomBase64String(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-random', 'getRandomBytes');\n  }\n}\nexport function getRandomBytesAsync(byteCount) {\n  var validByteCount, base64;\n  return _regeneratorRuntime.async(function getRandomBytesAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          assertByteCount(byteCount, 'getRandomBytesAsync');\n          validByteCount = Math.floor(byteCount);\n          if (!ExpoRandom.getRandomBytesAsync) {\n            _context.next = 8;\n            break;\n          }\n          _context.next = 5;\n          return _regeneratorRuntime.awrap(ExpoRandom.getRandomBytesAsync(validByteCount));\n        case 5:\n          return _context.abrupt(\"return\", _context.sent);\n        case 8:\n          if (!ExpoRandom.getRandomBase64StringAsync) {\n            _context.next = 15;\n            break;\n          }\n          _context.next = 11;\n          return _regeneratorRuntime.awrap(ExpoRandom.getRandomBase64StringAsync(validByteCount));\n        case 11:\n          base64 = _context.sent;\n          return _context.abrupt(\"return\", toByteArray(base64));\n        case 15:\n          throw new UnavailabilityError('expo-random', 'getRandomBytesAsync');\n        case 16:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}","map":{"version":3,"mappings":";AAAA,SAASA,mBAAmB,QAAQ,kBAAkB;AACtD,SAASC,WAAW,QAAQ,WAAW;AAEvC,OAAOC,UAAU;AAEjB,SAASC,eAAe,CAACC,KAAU,EAAEC,UAAkB;EACrD,IACE,OAAOD,KAAK,KAAK,QAAQ,IACzBE,KAAK,CAACF,KAAK,CAAC,IACZG,IAAI,CAACC,KAAK,CAACJ,KAAK,CAAC,GAAG,CAAC,IACrBG,IAAI,CAACC,KAAK,CAACJ,KAAK,CAAC,GAAG,IAAI,EACxB;IACA,MAAM,IAAIK,SAAS,mBACDJ,UAAU,SAAID,KAAK,mDACpC;;AAEL;AAEA,OAAM,SAAUM,cAAc,CAACC,SAAiB;EAC9CR,eAAe,CAACQ,SAAS,EAAE,gBAAgB,CAAC;EAC5C,IAAMC,cAAc,GAAGL,IAAI,CAACC,KAAK,CAACG,SAAS,CAAC;EAC5C,IAAIT,UAAU,CAACQ,cAAc,EAAE;IAC7B,OAAOR,UAAU,CAACQ,cAAc,CAACE,cAAc,CAAC;GACjD,MAAM,IAAIV,UAAU,CAACW,qBAAqB,EAAE;IAC3C,IAAMC,MAAM,GAAGZ,UAAU,CAACW,qBAAqB,CAACD,cAAc,CAAC;IAC/D,OAAOX,WAAW,CAACa,MAAM,CAAC;GAC3B,MAAM;IACL,MAAM,IAAId,mBAAmB,CAAC,aAAa,EAAE,gBAAgB,CAAC;;AAElE;AAEA,OAAO,SAAee,mBAAmB,CAACJ,SAAiB;EAAA;EAAA;IAAA;MAAA;QAAA;UACzDR,eAAe,CAACQ,SAAS,EAAE,qBAAqB,CAAC;UAC3CC,cAAc,GAAGL,IAAI,CAACC,KAAK,CAACG,SAAS,CAAC;UAAA,KACxCT,UAAU,CAACa,mBAAmB;YAAA;YAAA;UAAA;UAAA;UAAA,iCACnBb,UAAU,CAACa,mBAAmB,CAACH,cAAc,CAAC;QAAA;UAAA;QAAA;UAAA,KAClDV,UAAU,CAACc,0BAA0B;YAAA;YAAA;UAAA;UAAA;UAAA,iCACzBd,UAAU,CAACc,0BAA0B,CAACJ,cAAc,CAAC;QAAA;UAApEE,MAAM;UAAA,iCACLb,WAAW,CAACa,MAAM,CAAC;QAAA;UAAA,MAEpB,IAAId,mBAAmB,CAAC,aAAa,EAAE,qBAAqB,CAAC;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA;AAAA","names":["UnavailabilityError","toByteArray","ExpoRandom","assertByteCount","value","methodName","isNaN","Math","floor","TypeError","getRandomBytes","byteCount","validByteCount","getRandomBase64String","base64","getRandomBytesAsync","getRandomBase64StringAsync"],"sourceRoot":"","sources":["../src/Random.ts"],"sourcesContent":["import { UnavailabilityError } from '@unimodules/core';\nimport { toByteArray } from 'base64-js';\n\nimport ExpoRandom from './ExpoRandom';\n\nfunction assertByteCount(value: any, methodName: string): void {\n  if (\n    typeof value !== 'number' ||\n    isNaN(value) ||\n    Math.floor(value) < 0 ||\n    Math.floor(value) > 1024\n  ) {\n    throw new TypeError(\n      `expo-random: ${methodName}(${value}) expected a valid number from range 0...1024`\n    );\n  }\n}\n\nexport function getRandomBytes(byteCount: number): Uint8Array {\n  assertByteCount(byteCount, 'getRandomBytes');\n  const validByteCount = Math.floor(byteCount);\n  if (ExpoRandom.getRandomBytes) {\n    return ExpoRandom.getRandomBytes(validByteCount);\n  } else if (ExpoRandom.getRandomBase64String) {\n    const base64 = ExpoRandom.getRandomBase64String(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-random', 'getRandomBytes');\n  }\n}\n\nexport async function getRandomBytesAsync(byteCount: number): Promise<Uint8Array> {\n  assertByteCount(byteCount, 'getRandomBytesAsync');\n  const validByteCount = Math.floor(byteCount);\n  if (ExpoRandom.getRandomBytesAsync) {\n    return await ExpoRandom.getRandomBytesAsync(validByteCount);\n  } else if (ExpoRandom.getRandomBase64StringAsync) {\n    const base64 = await ExpoRandom.getRandomBase64StringAsync(validByteCount);\n    return toByteArray(base64);\n  } else {\n    throw new UnavailabilityError('expo-random', 'getRandomBytesAsync');\n  }\n}\n"]},"metadata":{},"sourceType":"module"}